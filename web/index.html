<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmony Web Viewer</title>
    <script src="jmuxer.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-mocha: #1e1e2e;
            --surface-mocha: #313244;
            --text-mocha: #cdd6f4;
            --lavender: #b4befe;
            --green: #a6e3a1;
            --red: #f38ba8;
            --overlay-bg: rgba(30, 30, 46, 0.85);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-mocha);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: var(--text-mocha);
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
        }

        #setup-screen,
        #waiting-screen {
            position: fixed;
            inset: 0;
            background-color: var(--bg-mocha);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease-in-out, visibility 0.5s;
        }

        .hidden {
            opacity: 0 !important;
            visibility: hidden !important;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 40px;
            width: 90%;
            max-width: 450px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            text-align: center;
            animation: fadeInScale 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(10px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        h1 {
            color: var(--lavender);
            font-weight: 600;
            margin-bottom: 30px;
            font-size: 2.2rem;
            letter-spacing: -0.5px;
        }

        .input-group {
            margin-bottom: 25px;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
            opacity: 0.8;
            padding-left: 5px;
        }

        input[type="text"],
        input[type="password"] {
            width: 100%;
            padding: 14px 20px;
            background: var(--surface-mocha);
            border: 2px solid transparent;
            border-radius: 12px;
            color: var(--text-mocha);
            font-size: 1rem;
            outline: none;
            transition: all 0.3s;
            box-sizing: border-box;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        input[type="text"]:focus,
        input[type="password"]:focus {
            border-color: var(--lavender);
            background: #45475a;
            box-shadow: 0 0 15px rgba(180, 190, 254, 0.2);
        }

        button {
            width: 100%;
            padding: 14px;
            background-color: var(--lavender);
            color: var(--bg-mocha);
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.320, 1);
            margin-top: 10px;
            box-shadow: 0 4px 15px rgba(180, 190, 254, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(180, 190, 254, 0.4);
            filter: brightness(1.1);
        }

        button:active {
            transform: translateY(1px);
        }

        .waiting-text {
            font-size: 1.5rem;
            font-weight: 400;
            opacity: 0.9;
            margin-top: 20px;
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid var(--surface-mocha);
            border-bottom-color: var(--lavender);
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }

        @keyframes rotation {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        video {
            max-width: 100%;
            max-height: 100%;
            background: #000;
        }

        #status {
            position: absolute;
            top: 25px;
            left: 25px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
            transition: all 0.5s;
            opacity: 0;
            z-index: 200;
        }

        #status.visible {
            opacity: 1;
        }

        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: var(--red);
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 8px var(--red);
        }

        .connected .status-dot {
            background-color: var(--green);
            box-shadow: 0 0 10px var(--green);
        }

        .status-text {
            font-weight: 500;
        }

        .connecting-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0% {
                content: '.';
            }

            33% {
                content: '..';
            }

            66% {
                content: '...';
            }
        }
    </style>
</head>

<body>
    <div id="setup-screen">
        <div class="glass-card">
            <h1>Harmony</h1>
            <div class="input-group">
                <label for="host-input">Host Address (IPv4)</label>
                <input type="text" id="host-input" placeholder="e.g. 192.168.1.10" spellcheck="false">
            </div>
            <div class="input-group">
                <label for="pass-input">Stream Password</label>
                <input type="password" id="pass-input" placeholder="Leave empty if none" spellcheck="false">
            </div>
            <button id="connect-btn">Connect to Stream</button>
        </div>
    </div>

    <div id="waiting-screen" class="hidden">
        <span class="loader"></span>
        <div class="waiting-text">Waiting for stream...</div>
    </div>

    <div id="container">
        <video id="player" autoplay muted playsinline></video>
        <div id="status">
            <span class="status-dot"></span>
            <span id="status-text" class="status-text">Disconnected</span>
        </div>
    </div>

    <script>
        const video = document.getElementById('player');
        const statusDiv = document.getElementById('status');
        const statusText = document.getElementById('status-text');
        const setupScreen = document.getElementById('setup-screen');
        const waitingScreen = document.getElementById('waiting-screen');
        const connectBtn = document.getElementById('connect-btn');
        const hostInput = document.getElementById('host-input');
        const passInput = document.getElementById('pass-input');

        // State constants
        const STATE_SETUP = 'setup';
        const STATE_WAITING = 'waiting';
        const STATE_STREAMING = 'streaming';

        let currentState = STATE_SETUP;
        let ws;
        let targetHost = '';
        let frameReceived = false;

        // Initialize host input from saved value or current domain
        hostInput.value = localStorage.getItem('harmony_host') || window.location.hostname || '';
        passInput.value = localStorage.getItem('harmony_pass') || '';

        let cryptoKey = null;

        // JMuxer instance
        const jmuxer = new JMuxer({
            node: 'player',
            mode: 'both',
            flushingTime: 0,
            maxDelay: 100,
            clearBuffer: true,
            fps: 60,
            debug: false
        });

        async function deriveKey(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hash = await crypto.subtle.digest('SHA-1', data);
            // Use first 16 bytes for AES-CTR
            const keyData = hash.slice(0, 16);
            return await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'AES-CTR' },
                false,
                ['decrypt']
            );
        }

        function setState(state) {
            currentState = state;
            console.log(`State changed to: ${state}`);

            // Visibility management
            setupScreen.classList.toggle('hidden', state !== STATE_SETUP);
            waitingScreen.classList.toggle('hidden', state !== STATE_WAITING);
            statusDiv.classList.toggle('visible', state !== STATE_SETUP);

            if (state === STATE_SETUP) {
                statusDiv.classList.remove('connected');
                statusText.innerText = "Disconnected";
            }
        }

        async function connect() {
            if (!targetHost) return;

            setState(STATE_WAITING);
            frameReceived = false;

            const password = passInput.value.trim();
            if (password) {
                cryptoKey = await deriveKey(password);
            } else {
                cryptoKey = null;
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const url = `${protocol}//${targetHost}:8080`;

            console.log(`Connecting to ${url}...`);
            statusText.innerHTML = `Connecting <span class="connecting-dots"></span>`;
            statusDiv.classList.remove('connected');

            if (ws) ws.close(); // Close existing connection if any
            ws = new WebSocket(url);
            ws.binaryType = 'arraybuffer';

            let messageQueue = Promise.resolve();

            ws.onopen = () => {
                console.log('Connected to WebSocket Server');
                statusDiv.classList.add('connected');
                statusText.innerText = `Connected to ${targetHost}`;
                // Keep STATE_WAITING until first frame
            };

            ws.onmessage = (event) => {
                // Sequential processing to avoid out-of-order issues from async decryption
                messageQueue = messageQueue.then(async () => {
                    let data = new Uint8Array(event.data);

                    // Prepend 4 bytes for frame_id, 1 byte for type
                    if (data.length < 5) return;

                    const frameIdBytes = data.slice(0, 4);
                    const packetType = data[4];
                    const actualData = data.slice(5);

                    let decryptedData = actualData;
                    if (cryptoKey && packetType === 0) { // Only decrypt VIDEO (0)
                        const iv = new Uint8Array(16);
                        iv.set(frameIdBytes, 0); // frame_id is big-endian from C (htonl)

                        try {
                            const decryptedBuffer = await crypto.subtle.decrypt(
                                {
                                    name: 'AES-CTR',
                                    counter: iv,
                                    length: 64
                                },
                                cryptoKey,
                                actualData
                            );
                            decryptedData = new Uint8Array(decryptedBuffer);
                        } catch (e) {
                            console.error('Decryption failed', e);
                            return;
                        }
                    }

                    if (!frameReceived && packetType === 0) {
                        console.log('First video frame received! Transitioning to streaming.');
                        frameReceived = true;
                        setState(STATE_STREAMING);
                    }

                    if (packetType === 0) {
                        jmuxer.feed({ video: decryptedData });
                    } else if (packetType === 4) {
                        jmuxer.feed({ audio: decryptedData });
                    }
                });
            };

            ws.onclose = () => {
                console.log('Disconnected');
                statusDiv.classList.remove('connected');

                if (currentState !== STATE_SETUP) { // Only auto-retry if not explicitly in setup state
                    statusText.innerText = "Disconnected (Retrying...)";
                    setState(STATE_WAITING); // Go back to waiting screen
                    // Auto-retry
                    setTimeout(connect, 2000);
                }
            };

            ws.onerror = (err) => {
                console.error('Socket Error:', err);
                ws.close();
            };
        }

        connectBtn.addEventListener('click', () => {
            targetHost = hostInput.value.trim();
            if (targetHost) {
                localStorage.setItem('harmony_host', targetHost);
                localStorage.setItem('harmony_pass', passInput.value.trim());
                connect();
            }
        });

        passInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') connectBtn.click();
        });

        hostInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') connectBtn.click();
        });

        video.addEventListener('click', () => {
            video.muted = false;
            video.play().catch(console.error);
        });
    </script>
</body>

</html>